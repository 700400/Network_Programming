# 비연결형 소켓 기반한 클라이언트-서버 실습
## 1.구현한 클라이언트-서버 설명
```
교수님께서 교안으로 올려주신 서버와 클라이언트에서
서버는 코드를 고치기 난해해서 바꾸지 않았고
클라이언트에서 키보드로 입력 받아서 서버와 송수신 하는 부분을 3번 반복하도록 하고
소켓의 넘버와 문자열의 길이를 출력하도록 구현해봤습니다
```

---

## 2. 클라이언트-서버 소스
### 서버
![1](/img2/C_server1.JPG)
![1](/img2/C_server2.JPG)
![1](/img2/C_server3.JPG)

``` c
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>
#include <stdlib.h>
#define BUF_LEN 128
// 동작에 필요한 헤더파일들, 버퍼의 최대 길이를 128로 선언하기 위한 define문

int main(int argc, char *argv[]){
	struct sockaddr_in server_addr, client_addr;		//소켓 번호를 표현하기위한 주소 구조체 2개 선언
	int s;							// 소켓 번호 변수 선언
	int len, msg_size;					// len과 메시지 길이 변수 선언
	char buf[BUF_LEN+1];					// 송수신할 떄 사용할 버퍼를 최대 버퍼 길이 +1로 선언
	

	if(argc != 2) {						// 들어오는 인자가 2개가 아니면 올바른 사용법을 알려줌
		printf("usage: %s port\n", argv[0]);
		exit(0);
	}

	if((s=socket(PF_INET, SOCK_DGRAM, 0))<0) {		// 소켓 생성, 도메인은 ipv4를 사용하고, 타입은 udp, 프로토콜은 기본 0
		printf("Server: Can't open datagram socket.");	// 만약 0보다 작으면 잘못되었다고 출력함. 0보다 작을 때 출력하는 이유는
		exit(0);					// 문제가 발생할 때 -1을 반환하기 때문
	}

	bzero((char *)&server_addr, sizeof(server_addr));	//bzero는 server_addr과 client_addr을 \0으로 초기화 하는 함수
	bzero((char *)&client_addr, sizeof(client_addr));	//인자로 char를 받기 때문에 형변환을 해줌 두 _addr 구조체는 16바이트

	server_addr.sin_family = AF_INET;			//도메인은 ipv4인 AF_INET
	server_addr.sin_addr.s_addr = htonl(INADDR_ANY);	//여러 주소를 가질 수 있기 때문에 INADDR_ANY 사용, 네트워크 바이트 순서로
								//변환해서 내부에 있는 .s_addr인 32비트 정수값에 할당
	server_addr.sin_port = htons(atoi(argv[1]));		//포트 번호는 벡터 1에 들어와있고 이건 3000이라는 문자열의 시작주소
								//문자열 3000을 정수로 바꾸고 shotr타입의 네트워크 바이트 순서로 변환후 할당

	if(bind(s, (struct sockaddr *)&server_addr, sizeof(server_addr)) <0) {
		printf("Server: Can't bind local address.\n");
		exit(0);
	}
	len = sizeof(struct sockaddr);

	while(1) {
		printf("Server : waiting request.\n");

		if((msg_size = recvfrom(s, buf, BUF_LEN, 0,(struct sockaddr *)&client_addr, &len))<0){
			printf("recvfrom error\n");
			exit(1);
		}
		printf("Server : A client data received.\n");

		if(sendto(s, buf, msg_size, 0, (struct sockaddr *)&client_addr, len)<0) {
			exit(1);
		}
		printf("sendto complete\n");
	}

	
}

```

``` c
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <string.h>
#include <stdlib.h>
#define BUF_LEN 128
// 동작에 필요한 헤더파일들, 버퍼의 최대 길이를 128로 선언하기 위한 define문

int main(int argc, char *argv[]){
	struct sockaddr_in server_addr, client_addr;		//소켓 번호를 표현하기위한 주소 구조체 2개 선언
	int s;												// 소켓 번호 변수 선언
	int len, msg_size;									// len과 메시지 길이 변수 선언
	char buf[BUF_LEN+1];								// 송수신할 떄 사용할 버퍼를 최대 버퍼 길이 +1로 선언
	

	if(argc != 2) {										// 들어오는 인자가 2개가 아니면 올바른 사용법을 알려줌
		printf("usage: %s port\n", argv[0]);
		exit(0);
	}

	if((s=socket(PF_INET, SOCK_DGRAM, 0))<0) {			// 소켓 생성, 도메인은 ipv4를 사용하고, 타입은 udp, 프로토콜은 기본 0
		printf("Server: Can't open datagram socket.");	// 만약 0보다 작으면 잘못되었다고 출력함. 0보다 작을 때 출력하는 이유는
		exit(0);										// 문제가 발생할 때 -1을 반환하기 때문
	}

	bzero((char *)&server_addr, sizeof(server_addr));	//bzero는 server_addr과 client_addr을 \0으로 초기화 하는 함수
	bzero((char *)&client_addr, sizeof(client_addr));	//인자로 char를 받기 때문에 형변환을 해줌 두 _addr 구조체는 16바이트

	server_addr.sin_family = AF_INET;					//도메인은 ipv4인 AF_INET
	server_addr.sin_addr.s_addr = htonl(INADDR_ANY);	//여러 주소를 가질 수 있기 때문에 INADDR_ANY 사용, 네트워크 바이트 순서로
														//변환해서 내부에 있는 .s_addr인 32비트 정수값에 할당
	server_addr.sin_port = htons(atoi(argv[1]));		//포트 번호는 벡터 1에 들어와있고 이건 3000이라는 문자열의 시작주소
														//문자열 3000을 정수로 바꾸고 shotr타입의 네트워크 바이트 순서로 변환후 할당


	if(bind(s, (struct sockaddr *)&server_addr, sizeof(server_addr)) <0) {	 
		printf("Server: Can't bind local address.\n");						
		exit(0);															
	}																		 
	// 소켓 번호와 소켓 주소를 결합하는 것이 바인드
	// sizeof는 인자의 크기를 나타내줌 - 16바이트 
	// server_addr은 현재 sockaddr_in의 구조체임
	// bind의 2번째 인자는 sockaddr 구조체가 되어야해서 형변환하게 됨
	// 이것 또한 문제가 발생시 -1을 반환해서 <0 일때 에러가 발생했다고 표시  
	
	len = sizeof(struct sockaddr);						// len에 sockaddr의 크기인 16바이트를 할당 

	while(1) {
		printf("Server : waiting request.\n");

		if((msg_size = recvfrom(s, buf, BUF_LEN, 0,(struct sockaddr *)&client_addr, &len))<0){
			printf("recvfrom error\n");
			exit(1);
		}
		// 데이터를 수신하는 recvfrom의 인자로 소켓번호, 문자 배열의 시작주소인 buf, 버퍼의 길이
		// 받는 방법 - default 인 0
		// echo를 하기 위해 클라이언트의 주소를 담아놓고 다시 보내기 위해
		// 바인드 할때와 마찬가지로 인자로 sockaddr구조체를 필요로 하기 때문에 형 변환 
		// 메시지의 길이는 16이 저장된 메시지의 주소값을 주게됨
		// 이것이 에러면 에러를 출력 
		
		
		printf("Server : A client data received.\n");		// 성공적으로 받으면 해당 문장 출력

		if(sendto(s, buf, msg_size, 0, (struct sockaddr *)&client_addr, len)<0) {
			printf("sendto error\n"); 
			exit(1);
		}
		// 받은걸 그대로 돌려주기 위해 sendto
		// 소켓 번호 s, 수신한 메시지가 버퍼에 들어가 있어서 그대로 버퍼 사용
		// 수신받은 길이만큼을 나타내는 msg_size를 사용
		// 받았던 곳으로 다시 재전송이라서 클라이언트 주소 재사용
		// len은 주소가 아닌 실제값 16 
		// 에러면 -1이니까  에러 메시지 출력 
		 
		printf("sendto complete\n");
	}	// 무한 루프 돌면서 실행 

	
}

```

---

### 클라이언트
![1](/img2/C_client1.JPG)
![1](/img2/C_client2.JPG)
![1](/img2/C_client3.JPG)

``` c
#include <stdio.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>
#define BUF_LEN 128

int main(int argc, char *argv[]) {
	int s, n, t, len_out, addrsize;
	struct sockaddr_in server_addr;
	char *haddr;
	char buf[BUF_LEN+1];

	if(argc != 3) {
		printf("usage: %s ip_address port_number\n", argv[0]);
		exit(0);
	}
	haddr = argv[1];

	if((s = socket(PF_INET, SOCK_DGRAM, 0)) <0) {
		printf("can't create socket\n");
		exit(0);
	}

	bzero((char *)&server_addr, sizeof(server_addr));
	server_addr.sin_family = AF_INET;
	server_addr.sin_addr.s_addr = inet_addr(haddr);
	server_addr.sin_port = htons(atoi(argv[2]));

	addrsize = sizeof(struct sockaddr);
	
	for(t=0;t<3;t++){
	
		printf("Input any string : ");
		if(fgets(buf, BUF_LEN, stdin)) {
			buf[BUF_LEN] = '\0';
			len_out = strlen(buf);
		} else {
			printf("fgets error\n");
			exit(0);
		}

		if(sendto(s, buf, len_out, 0, (struct sockaddr *)&server_addr, sizeof(struct sockaddr))<0) 
		{
			printf("sendto error\n");
			exit(0);
		}

		printf("Echoed string : ");
		if(recvfrom(s, buf, BUF_LEN, 0, (struct sockaddr *)&server_addr, &addrsize) < 0) {
			printf("recevfrom error\n");
			exit(0);
		}

		printf("%s\n", buf);
		printf("socket : %d , string length : %d \n", s, len_out);
	}
	close(s);
}
```

---

## 3. 클라이언트-서버 실행화면

![1](/img2/L_client.JPG)
![1](/img2/L_server.JPG)
